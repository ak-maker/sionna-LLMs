"# Neural Receiver for OFDM SIMO Systems\n\nIn this notebook, you will learn how to train a neural receiver that implements OFDM detection. The considered setup is shown in the figure below. As one can see, the neural receiver substitutes channel estimation, equalization, and demapping. It takes as input the post-DFT (discrete Fourier transform) received samples, which form the received resource grid, and computes log-likelihood ratios (LLRs) on the transmitted coded bits. These LLRs are then fed to the outer decoder to reconstruct the\ntransmitted information bits.\n\n\nTwo baselines are considered for benchmarking, which are shown in the figure above. Both baselines use linear minimum mean square error (LMMSE) equalization and demapping assuming additive white Gaussian noise (AWGN). They differ by how channel estimation is performed:\n\n- **Pefect CSI**: Perfect channel state information (CSI) knowledge is assumed.\n- **LS estimation**: Uses the transmitted pilots to perform least squares (LS) estimation of the channel with nearest-neighbor interpolation.\n\n\nAll the considered end-to-end systems use an LDPC outer code from the 5G NR specification, QPSK modulation, and a 3GPP CDL channel model simulated in the frequency domain."
"## GPU Configuration and Imports\n\n\n```python\nimport os\ngpu_num = 0 # Use \"\" to use the CPU\nos.environ[\"CUDA_VISIBLE_DEVICES\"] = f\"{gpu_num}\"\nos.environ['TF_CPP_MIN_LOG_LEVEL'] = '3'\n# Import Sionna\ntry:\n    import sionna\nexcept ImportError as e:\n    # Install Sionna if package is not already installed\n    import os\n    os.system(\"pip install sionna\")\n    import sionna\n# Configure the notebook to use only a single GPU and allocate only as much memory as needed\n# For more details, see https://www.tensorflow.org/guide/gpu\nimport tensorflow as tf\ngpus = tf.config.list_physical_devices('GPU')\nif gpus:\n    try:\n        tf.config.experimental.set_memory_growth(gpus[0], True)\n    except RuntimeError as e:\n        print(e)\n# Avoid warnings from TensorFlow\ntf.get_logger().setLevel('ERROR')\n```\n\n```python\n%matplotlib inline\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pickle\nfrom tensorflow.keras import Model\nfrom tensorflow.keras.layers import Layer, Conv2D, LayerNormalization\nfrom tensorflow.nn import relu\nfrom sionna.channel.tr38901 import Antenna, AntennaArray, CDL\nfrom sionna.channel import OFDMChannel\nfrom sionna.mimo import StreamManagement\nfrom sionna.ofdm import ResourceGrid, ResourceGridMapper, LSChannelEstimator, LMMSEEqualizer, RemoveNulledSubcarriers, ResourceGridDemapper\nfrom sionna.utils import BinarySource, ebnodb2no, insert_dims, flatten_last_dims, log10, expand_to_rank\nfrom sionna.fec.ldpc.encoding import LDPC5GEncoder\nfrom sionna.fec.ldpc.decoding import LDPC5GDecoder\nfrom sionna.mapping import Mapper, Demapper\nfrom sionna.utils.metrics import compute_ber\nfrom sionna.utils import sim_ber\n```"
"## Simulation Parameters\n\n\n```python\n############################################\n## Channel configuration\ncarrier_frequency = 3.5e9 # Hz\ndelay_spread = 100e-9 # s\ncdl_model = \"C\" # CDL model to use\nspeed = 10.0 # Speed for evaluation and training [m/s]\n# SNR range for evaluation and training [dB]\nebno_db_min = -5.0\nebno_db_max = 10.0\n############################################\n## OFDM waveform configuration\nsubcarrier_spacing = 30e3 # Hz\nfft_size = 128 # Number of subcarriers forming the resource grid, including the null-subcarrier and the guard bands\nnum_ofdm_symbols = 14 # Number of OFDM symbols forming the resource grid\ndc_null = True # Null the DC subcarrier\nnum_guard_carriers = [5, 6] # Number of guard carriers on each side\npilot_pattern = \"kronecker\" # Pilot pattern\npilot_ofdm_symbol_indices = [2, 11] # Index of OFDM symbols carrying pilots\ncyclic_prefix_length = 0 # Simulation in frequency domain. This is useless\n############################################\n## Modulation and coding configuration\nnum_bits_per_symbol = 2 # QPSK\ncoderate = 0.5 # Coderate for instruction_answer code\n############################################\n## Neural receiver configuration\nnum_conv_channels = 128 # Number of convolutional channels for the convolutional layers forming the neural receiver\n############################################\n## Training configuration\nnum_training_iterations = 30000 # Number of training iterations\ntraining_batch_size = 128 # Training batch size\nmodel_weights_path = \"neural_receiver_weights\" # Location to save the neural receiver weights once training is done\n############################################\n## Evaluation configuration\nresults_filename = \"neural_receiver_results\" # Location to save the results\n```\n\n\nThe `StreamManagement` class is used to configure the receiver-transmitter association and the number of streams per transmitter. A SIMO system is considered, with a single transmitter equipped with a single non-polarized antenna. Therefore, there is only a single stream, and the receiver-transmitter association matrix is $[1]$. The receiver is equipped with an antenna array.\n\n\n```python\nstream_manager = StreamManagement(np.array([[1]]), # Receiver-transmitter association matrix\n                                  1)               # One stream per transmitter\n```"
"The `ResourceGrid` class is used to configure the OFDM resource grid. It is initialized with the parameters defined above.\n\n\n```python\nresource_grid = ResourceGrid(num_ofdm_symbols = num_ofdm_symbols,\n                             fft_size = fft_size,\n                             subcarrier_spacing = subcarrier_spacing,\n                             num_tx = 1,\n                             num_streams_per_tx = 1,\n                             cyclic_prefix_length = cyclic_prefix_length,\n                             dc_null = dc_null,\n                             pilot_pattern = pilot_pattern,\n                             pilot_ofdm_symbol_indices = pilot_ofdm_symbol_indices,\n                             num_guard_carriers = num_guard_carriers)\n```\n\n\nOuter coding is performed such that all the databits carried by the resource grid with size `fft_size`x`num_ofdm_symbols` form a single codeword.\n\n\n```python\n# Codeword length. It is calculated from the total number of databits carried by the resource grid, and the number of bits transmitted per resource element\nn = int(resource_grid.num_data_symbols*num_bits_per_symbol)\n# Number of information bits per codeword\nk = int(n*coderate)\n```\n\n\nThe SIMO link is setup by considering an uplink transmission with one user terminal (UT) equipped with a single non-polarized antenna, and a base station (BS) equipped with an antenna array. One can try other configurations for the BS antenna array.\n\n\n```python\nut_antenna = Antenna(polarization=\"single\",\n                     polarization_type=\"V\",\n                     antenna_pattern=\"38.901\",\n                     carrier_frequency=carrier_frequency)\nbs_array = AntennaArray(num_rows=1,\n                        num_cols=1,\n                        polarization=\"dual\",\n                        polarization_type=\"VH\",\n                        antenna_pattern=\"38.901\",\n                        carrier_frequency=carrier_frequency)\n```"
"## Neural Receiver\n\nThe next cell defines the Keras layers that implement the neural receiver. As in [1] and [2], a neural receiver using residual convolutional layers is implemented. Convolutional layers are leveraged to efficienly process the 2D resource grid, that is fed as an input to the neural receiver. Residual (skip) connections are used to avoid gradient vanishing [3].\n\nFor convinience, a Keras layer that implements a *residual block* is first defined. The Keras layer that implements the neural receiver is built by stacking such blocks. The following figure shows the architecture of the neural receiver.\n\n\n```python\nclass ResidualBlock(Layer):\n    r\"\"\"\n    This Keras layer implements a convolutional residual block made of two convolutional layers with ReLU activation, layer normalization, and a skip connection.\n    The number of convolutional channels of the input must match the number of kernel of the convolutional layers ``num_conv_channel`` for the skip connection to work.\n    Input\n    ------\n    : [batch size, num time samples, num subcarriers, num_conv_channel], tf.float\n        Input of the layer\n    Output\n    -------\n    : [batch size, num time samples, num subcarriers, num_conv_channel], tf.float\n        Output of the layer\n    \"\"\"\n    def build(self, input_shape):\n        # Layer normalization is done over the last three dimensions: time, frequency, conv 'channels'\n        self._layer_norm_1 = LayerNormalization(axis=(-1, -2, -3))\n        self._conv_1 = Conv2D(filters=num_conv_channels,\n                              kernel_size=[3,3],\n                              padding='same',\n                              activation=None)\n        # Layer normalization is done over the last three dimensions: time, frequency, conv 'channels'\n        self._layer_norm_2 = LayerNormalization(axis=(-1, -2, -3))\n        self._conv_2 = Conv2D(filters=num_conv_channels,\n                              kernel_size=[3,3],\n                              padding='same',\n                              activation=None)\n    def call(self, inputs):\n        z = self._layer_norm_1(inputs)\n        z = relu(z)\n        z = self._conv_1(z)\n        z = self._layer_norm_2(z)\n        z = relu(z)\n        z = self._conv_2(z) # [batch size, num time samples, num subcarriers, num_channels]\n        # Skip connection\n        z = z + inputs\n        return z\nclass NeuralReceiver(Layer):\n    r\"\"\"\n    Keras layer implementing a residual convolutional neural receiver.\n    This neural receiver is fed with the post-DFT received samples, forming a resource grid of size num_of_symbols x fft_size, and computes LLRs on the transmitted coded bits.\n    These LLRs can then be fed to an outer decoder to reconstruct the information bits.\n    As the neural receiver is fed with the entire resource grid, including the guard bands and pilots, it also computes LLRs for these resource elements.\n    They must be discarded to only keep the LLRs corresponding to the data-carrying resource elements.\n    Input\n    ------\n    y : [batch size, num rx antenna, num ofdm symbols, num subcarriers], tf.complex\n        Received post-DFT samples.\n    no : [batch size], tf.float32\n        Noise variance. At training, a different noise variance value is sampled for each batch example.\n    Output\n    -------\n    : [batch size, num ofdm symbols, num subcarriers, num_bits_per_symbol]\n        LLRs on the transmitted bits.\n        LLRs computed for resource elements not carrying data (pilots, guard bands...) must be discarded.\n    \"\"\"\n    def build(self, input_shape):\n        # Input convolution\n        self._input_conv = Conv2D(filters=num_conv_channels,\n                                  kernel_size=[3,3],\n                                  padding='same',\n                                  activation=None)\n        # Residual blocks\n        self._res_block_1 = ResidualBlock()\n        self._res_block_2 = ResidualBlock()\n        self._res_block_3 = ResidualBlock()\n        self._res_block_4 = ResidualBlock()\n        # Output conv\n        self._output_conv = Conv2D(filters=num_bits_per_symbol,\n                                   kernel_size=[3,3],\n                                   padding='same',\n                                   activation=None)\n    def call(self, inputs):\n        y, no = inputs\n        # Feeding the noise power in log10 scale helps with the performance\n        no = log10(no)\n        # Stacking the real and imaginary components of the different antennas along the 'channel' dimension\n        y = tf.transpose(y, [0, 2, 3, 1]) # Putting antenna dimension last\n        no = insert_dims(no, 3, 1)\n        no = tf.tile(no, [1, y.shape[1], y.shape[2], 1])\n        # z : [batch size, num ofdm symbols, num subcarriers, 2*num rx antenna + 1]\n        z = tf.concat([tf.math.real(y),\n                       tf.math.imag(y),\n                       no], axis=-1)\n        # Input conv\n        z = self._input_conv(z)\n        # Residual blocks\n        z = self._res_block_1(z)\n        z = self._res_block_2(z)\n        z = self._res_block_3(z)\n        z = self._res_block_4(z)\n        # Output conv\n        z = self._output_conv(z)\n        return z\n```"
"## End-to-end System\n\nThe following cell defines the end-to-end system.\n\nTraining is done on the bit-metric decoding (BMD) rate which is computed from the transmitted bits and LLRs:\n\n\\begin{equation}\nR = 1 - \\frac{1}{SNMK} \\sum_{s = 0}^{S-1} \\sum_{n = 0}^{N-1} \\sum_{m = 0}^{M-1} \\sum_{k = 0}^{K-1} \\texttt{BCE} \\left( B_{s,n,m,k}, \\texttt{LLR}_{s,n,m,k} \\right)\n\\end{equation}\n\nwhere\n\n- $S$ is the batch size\n- $N$ the number of subcarriers\n- $M$ the number of OFDM symbols\n- $K$ the number of bits per symbol\n- $B_{s,n,m,k}$ the $k^{th}$ coded bit transmitted on the resource element $(n,m)$ and for the $s^{th}$ batch example\n- $\\texttt{LLR}_{s,n,m,k}$ the LLR (logit) computed by the neural receiver corresponding to the $k^{th}$ coded bit transmitted on the resource element $(n,m)$ and for the $s^{th}$ batch example\n- $\\texttt{BCE} \\left( \\cdot, \\cdot \\right)$ the binary cross-entropy in log base 2\n\n\nBecause no outer code is required at training, the outer encoder and decoder are not used at training to reduce computational complexity.\n\nThe BMD rate is known to be an achievable information rate for BICM systems, which motivates its used as objective function [4].\n\n\n```python\n## Transmitter\nbinary_source = BinarySource()\nmapper = Mapper(\"qam\", num_bits_per_symbol)\nrg_mapper = ResourceGridMapper(resource_grid)\n## Channel\ncdl = CDL(cdl_model, delay_spread, carrier_frequency,\n          ut_antenna, bs_array, \"uplink\", min_speed=speed)\nchannel = OFDMChannel(cdl, resource_grid, normalize_channel=True, return_channel=True)\n## Receiver\nneural_receiver = NeuralReceiver()\nrg_demapper = ResourceGridDemapper(resource_grid, stream_manager) # Used to extract data-carrying resource elements\n```\n\n\nThe following cell performs one forward step through the end-to-end system:"
"```python\nbatch_size = 64\nebno_db = tf.fill([batch_size], 5.0)\nno = ebnodb2no(ebno_db, num_bits_per_symbol, coderate)\n\n## Transmitter\n# Generate codewords\nc = binary_source([batch_size, 1, 1, n])\nprint(\"c shape: \", c.shape)\n# Map bits to QAM symbols\nx = mapper(c)\nprint(\"x shape: \", x.shape)\n# Map the QAM symbols to a resource grid\nx_rg = rg_mapper(x)\nprint(\"x_rg shape: \", x_rg.shape)\n######################################\n## Channel\n# A batch of new channel realizations is sampled and applied at every inference\nno_ = expand_to_rank(no, tf.rank(x_rg))\ny,_ = channel([x_rg, no_])\nprint(\"y shape: \", y.shape)\n######################################\n## Receiver\n# The neural receover computes LLRs from the frequency domain received symbols and N0\ny = tf.squeeze(y, axis=1)\nllr = neural_receiver([y, no])\nprint(\"llr shape: \", llr.shape)\n# Reshape the input to fit what the resource grid demapper is expected\nllr = insert_dims(llr, 2, 1)\n# Extract data-carrying resource elements. The other LLRs are discarded\nllr = rg_demapper(llr)\nllr = tf.reshape(llr, [batch_size, 1, 1, n])\nprint(\"Post RG-demapper LLRs: \", llr.shape)\n```\n\n\n```python\nc shape:  (64, 1, 1, 2784)\nx shape:  (64, 1, 1, 1392)\nx_rg shape:  (64, 1, 1, 14, 128)\ny shape:  (64, 1, 2, 14, 128)\nllr shape:  (64, 14, 128, 2)\nPost RG-demapper LLRs:  (64, 1, 1, 2784)\n```\n\n\nThe BMD rate is computed from the LLRs and transmitted bits as follows:\n\n\n```python\nbce = tf.nn.sigmoid_cross_entropy_with_logits(c, llr)\nbce = tf.reduce_mean(bce)\nrate = tf.constant(1.0, tf.float32) - bce/tf.math.log(2.)\nprint(f\"Rate: {rate:.2E} bit\")\n```"
"## End-to-end System as a Keras Model\n\nThe following Keras *Model* implements the three considered end-to-end systems (perfect CSI baseline, LS estimation baseline, and neural receiver).\n\nWhen instantiating the Keras model, the parameter `system` is used to specify the system to setup, and the parameter `training` is used to specified if the system is instantiated to be trained or to be evaluated. The `training` parameter is only relevant when the neural receiver is used.\n\nAt each call of this model:\n\n- A batch of codewords is randomly sampled, modulated, and mapped to resource grids to form the channel inputs\n- A batch of channel realizations is randomly sampled and applied to the channel inputs\n- The receiver is executed on the post-DFT received samples to compute LLRs on the coded bits. Which receiver is executed (baseline with perfect CSI knowledge, baseline with LS estimation, or neural receiver) depends on the specified `system` parameter.\n- If not training, the outer decoder is applied to reconstruct the information bits\n- If training, the BMD rate is estimated over the batch from the LLRs and the transmitted bits\n\n```python\nclass E2ESystem(Model):\n    r\"\"\"\n    Keras model that implements the end-to-end systems.\n    As the three considered end-to-end systems (perfect CSI baseline, LS estimation baseline, and neural receiver) share most of\n    the link components (transmitter, channel model, outer code...), they are implemented using the same Keras model.\n    When instantiating the Keras model, the parameter ``system`` is used to specify the system to setup,\n    and the parameter ``training`` is used to specified if the system is instantiated to be trained or to be evaluated.\n    The ``training`` parameter is only relevant when the neural\n    At each call of this model:\n    * A batch of codewords is randomly sampled, modulated, and mapped to resource grids to form the channel inputs\n    * A batch of channel realizations is randomly sampled and applied to the channel inputs\n    * The receiver is executed on the post-DFT received samples to compute LLRs on the coded bits.\n      Which receiver is executed (baseline with perfect CSI knowledge, baseline with LS estimation, or neural receiver) depends\n      on the specified ``system`` parameter.\n    * If not training, the outer decoder is applied to reconstruct the information bits\n    * If training, the BMD rate is estimated over the batch from the LLRs and the transmitted bits\n    Parameters\n    -----------\n    system : str\n        Specify the receiver to use. Should be one of 'baseline-perfect-csi', 'baseline-ls-estimation' or 'neural-receiver'\n    training : bool\n        Set to `True` if the system is instantiated to be trained. Set to `False` otherwise. Defaults to `False`.\n        If the system is instantiated to be trained, the outer encoder and decoder are not instantiated as they are not required for training.\n        This significantly reduces the computational complexity of training.\n        If training, the bit-metric decoding (BMD) rate is computed from the transmitted bits and the LLRs. The BMD rate is known to be\n        an achievable information rate for BICM systems, and therefore training of the neural receiver aims at maximizing this rate.\n    Input\n    ------\n    batch_size : int\n        Batch size\n    no : scalar or [batch_size], tf.float\n        Noise variance.\n        At training, a different noise variance should be sampled for each batch example.\n    Output\n    -------\n    If ``training`` is set to `True`, then the output is a single scalar, which is an estimation of the BMD rate computed over the batch. It\n    should be used as objective for training.\n    If ``training`` is set to `False`, the transmitted information bits and their reconstruction on the receiver side are returned to\n    compute the block/bit error rate.\n    \"\"\"\n    def __init__(self, system, training=False):\n        super().__init__()\n        self._system = system\n        self._training = training\n        ######################################\n        ## Transmitter\n        self._binary_source = BinarySource()\n        # To reduce the computational complexity of training, the outer code is not used when training,\n        # as it is not required\n        if not training:\n            self._encoder = LDPC5GEncoder(k, n)\n        self._mapper = Mapper(\"qam\", num_bits_per_symbol)\n        self._rg_mapper = ResourceGridMapper(resource_grid)\n        ######################################\n        ## Channel\n        # A 3GPP CDL channel model is used\n        cdl = CDL(cdl_model, delay_spread, carrier_frequency,\n                  ut_antenna, bs_array, \"uplink\", min_speed=speed)\n        self._channel = OFDMChannel(cdl, resource_grid, normalize_channel=True, return_channel=True)\n        ######################################\n        ## Receiver\n        # Three options for the receiver depending on the value of `system`\n        if \"baseline\" in system:\n            if system == 'baseline-perfect-csi': # Perfect CSI\n                self._removed_null_subc = RemoveNulledSubcarriers(resource_grid)\n            elif system == 'baseline-ls-estimation': # LS estimation\n                self._ls_est = LSChannelEstimator(resource_grid, interpolation_type=\"nn\")\n            # Components required by both baselines\n            self._lmmse_equ = LMMSEEqualizer(resource_grid, stream_manager, )\n            self._demapper = Demapper(\"app\", \"qam\", num_bits_per_symbol)\n        elif system == \"neural-receiver\": # Neural receiver\n            self._neural_receiver = NeuralReceiver()\n            self._rg_demapper = ResourceGridDemapper(resource_grid, stream_manager) # Used to extract data-carrying resource elements\n        # To reduce the computational complexity of training, the outer code is not used when training,\n        # as it is not required\n        if not training:\n            self._decoder = LDPC5GDecoder(self._encoder, hard_out=True)\n    @tf.function\n    def call(self, batch_size, ebno_db):\n        # If `ebno_db` is a scalar, a tensor with shape [batch size] is created as it is what is expected by some layers\n        if len(ebno_db.shape) == 0:\n            ebno_db = tf.fill([batch_size], ebno_db)\n        ######################################\n        ## Transmitter\n        no = ebnodb2no(ebno_db, num_bits_per_symbol, coderate)\n        # Outer coding is only performed if not training\n        if self._training:\n            c = self._binary_source([batch_size, 1, 1, n])\n        else:\n            b = self._binary_source([batch_size, 1, 1, k])\n            c = self._encoder(b)\n        # Modulation\n        x = self._mapper(c)\n        x_rg = self._rg_mapper(x)\n        ######################################\n        ## Channel\n        # A batch of new channel realizations is sampled and applied at every inference\n        no_ = expand_to_rank(no, tf.rank(x_rg))\n        y,h = self._channel([x_rg, no_])\n        ######################################\n        ## Receiver\n        # Three options for the receiver depending on the value of ``system``\n        if \"baseline\" in self._system:\n            if self._system == 'baseline-perfect-csi':\n                h_hat = self._removed_null_subc(h) # Extract non-null subcarriers\n                err_var = 0.0 # No channel estimation error when perfect CSI knowledge is assumed\n            elif self._system == 'baseline-ls-estimation':\n                h_hat, err_var = self._ls_est([y, no]) # LS channel estimation with nearest-neighbor\n            x_hat, no_eff = self._lmmse_equ([y, h_hat, err_var, no]) # LMMSE equalization\n            no_eff_= expand_to_rank(no_eff, tf.rank(x_hat))\n            llr = self._demapper([x_hat, no_eff_]) # Demapping\n        elif self._system == \"neural-receiver\":\n            # The neural receover computes LLRs from the frequency domain received symbols and N0\n            y = tf.squeeze(y, axis=1)\n            llr = self._neural_receiver([y, no])\n            llr = insert_dims(llr, 2, 1) # Reshape the input to fit what the resource grid demapper is expected\n            llr = self._rg_demapper(llr) # Extract data-carrying resource elements. The other LLrs are discarded\n            llr = tf.reshape(llr, [batch_size, 1, 1, n]) # Reshape the LLRs to fit what the outer decoder is expected\n        # Outer coding is not needed if the information rate is returned\n        if self._training:\n            # Compute and return BMD rate (in bit), which is known to be an achievable\n            # information rate for BICM systems.\n            # Training aims at maximizing the BMD rate\n            bce = tf.nn.sigmoid_cross_entropy_with_logits(c, llr)\n            bce = tf.reduce_mean(bce)\n            rate = tf.constant(1.0, tf.float32) - bce/tf.math.log(2.)\n            return rate\n        else:\n            # Outer decoding\n            b_hat = self._decoder(llr)\n            return b,b_hat # Ground truth and reconstructed information bits returned for BER/BLER computation\n```"
"## Evaluation of the Baselines\n\nWe evaluate the BERs achieved by the baselines in the next cell.\n\n**Note:** Evaluation of the two systems can take a while. Therefore, we provide pre-computed results at the end of this notebook.\n\n\n```python\n# Range of SNRs over which the systems are evaluated\nebno_dbs = np.arange(ebno_db_min, # Min SNR for evaluation\n                     ebno_db_max, # Max SNR for evaluation\n                     0.5) # Step\n```\n\n```python\n# Dictionnary storing the evaluation results\nBLER = {}\nmodel = E2ESystem('baseline-perfect-csi')\n_,bler = sim_ber(model, ebno_dbs, batch_size=128, num_target_block_errors=100, max_mc_iter=100)\nBLER['baseline-perfect-csi'] = bler.numpy()\nmodel = E2ESystem('baseline-ls-estimation')\n_,bler = sim_ber(model, ebno_dbs, batch_size=128, num_target_block_errors=100, max_mc_iter=100)\nBLER['baseline-ls-estimation'] = bler.numpy()\n```\n\n\n```python\nEbNo [dB] |        BER |       BLER |  bit errors |    num bits | block errors |  num blocks | runtime [s] |    status\n---------------------------------------------------------------------------------------------------------------------------------------\n     -5.0 | 2.5345e-01 | 1.0000e+00 |       45158 |      178176 |          128 |         128 |         7.3 |reached target block errors\n     -4.5 | 2.3644e-01 | 1.0000e+00 |       42128 |      178176 |          128 |         128 |         0.1 |reached target block errors\n     -4.0 | 2.1466e-01 | 1.0000e+00 |       38248 |      178176 |          128 |         128 |         0.1 |reached target block errors\n     -3.5 | 1.9506e-01 | 1.0000e+00 |       34755 |      178176 |          128 |         128 |         0.1 |reached target block errors\n     -3.0 | 1.6194e-01 | 1.0000e+00 |       28853 |      178176 |          128 |         128 |         0.1 |reached target block errors\n     -2.5 | 1.0628e-01 | 9.9219e-01 |       18937 |      178176 |          127 |         128 |         0.1 |reached target block errors\n     -2.0 | 1.8395e-02 | 5.6250e-01 |        6555 |      356352 |          144 |         256 |         0.2 |reached target block errors\n     -1.5 | 6.6440e-04 | 2.7478e-02 |        3433 |     5167104 |          102 |        3712 |         3.2 |reached target block errors\n     -1.0 | 8.7161e-05 | 1.4844e-03 |        1553 |    17817600 |           19 |       12800 |        10.9 |reached max iter\n     -0.5 | 2.8904e-05 | 7.8125e-04 |         515 |    17817600 |           10 |       12800 |        10.9 |reached max iter\n      0.0 | 1.2347e-05 | 1.5625e-04 |         220 |    17817600 |            2 |       12800 |        10.9 |reached max iter\n      0.5 | 1.1337e-05 | 7.8125e-05 |         202 |    17817600 |            1 |       12800 |        10.8 |reached max iter\n      1.0 | 8.0819e-06 | 7.8125e-05 |         144 |    17817600 |            1 |       12800 |        10.9 |reached max iter\n      1.5 | 1.6837e-07 | 7.8125e-05 |           3 |    17817600 |            1 |       12800 |        10.9 |reached max iter\n      2.0 | 0.0000e+00 | 0.0000e+00 |           0 |    17817600 |            0 |       12800 |        10.9 |reached max iter\nSimulation stopped as no error occurred @ EbNo = 2.0 dB.\nEbNo [dB] |        BER |       BLER |  bit errors |    num bits | block errors |  num blocks | runtime [s] |    status\n---------------------------------------------------------------------------------------------------------------------------------------\n     -5.0 | 3.9096e-01 | 1.0000e+00 |       69659 |      178176 |          128 |         128 |         2.8 |reached target block errors\n     -4.5 | 3.8028e-01 | 1.0000e+00 |       67756 |      178176 |          128 |         128 |         0.1 |reached target block errors\n     -4.0 | 3.6582e-01 | 1.0000e+00 |       65180 |      178176 |          128 |         128 |         0.1 |reached target block errors\n     -3.5 | 3.5540e-01 | 1.0000e+00 |       63324 |      178176 |          128 |         128 |         0.1 |reached target block errors\n     -3.0 | 3.4142e-01 | 1.0000e+00 |       60833 |      178176 |          128 |         128 |         0.1 |reached target block errors\n     -2.5 | 3.2873e-01 | 1.0000e+00 |       58572 |      178176 |          128 |         128 |         0.1 |reached target block errors\n     -2.0 | 3.1137e-01 | 1.0000e+00 |       55478 |      178176 |          128 |         128 |         0.1 |reached target block errors\n     -1.5 | 2.9676e-01 | 1.0000e+00 |       52875 |      178176 |          128 |         128 |         0.1 |reached target block errors\n     -1.0 | 2.7707e-01 | 1.0000e+00 |       49368 |      178176 |          128 |         128 |         0.1 |reached target block errors\n     -0.5 | 2.5655e-01 | 1.0000e+00 |       45711 |      178176 |          128 |         128 |         0.1 |reached target block errors\n      0.0 | 2.3697e-01 | 1.0000e+00 |       42223 |      178176 |          128 |         128 |         0.1 |reached target block errors\n      0.5 | 2.0973e-01 | 1.0000e+00 |       37369 |      178176 |          128 |         128 |         0.1 |reached target block errors\n      1.0 | 1.6844e-01 | 1.0000e+00 |       30012 |      178176 |          128 |         128 |         0.1 |reached target block errors\n      1.5 | 8.5578e-02 | 9.2969e-01 |       15248 |      178176 |          119 |         128 |         0.1 |reached target block errors\n      2.0 | 1.0147e-02 | 2.5195e-01 |        7232 |      712704 |          129 |         512 |         0.4 |reached target block errors\n      2.5 | 7.8271e-04 | 1.2401e-02 |        8786 |    11225088 |          100 |        8064 |         6.9 |reached target block errors\n      3.0 | 2.1866e-04 | 2.1094e-03 |        3896 |    17817600 |           27 |       12800 |        11.0 |reached max iter\n      3.5 | 9.0528e-05 | 7.0312e-04 |        1613 |    17817600 |            9 |       12800 |        10.9 |reached max iter\n      4.0 | 2.9634e-05 | 2.3437e-04 |         528 |    17817600 |            3 |       12800 |        11.0 |reached max iter\n      4.5 | 1.9868e-05 | 1.5625e-04 |         354 |    17817600 |            2 |       12800 |        10.9 |reached max iter\n      5.0 | 3.8445e-05 | 2.3437e-04 |         685 |    17817600 |            3 |       12800 |        10.9 |reached max iter\n      5.5 | 0.0000e+00 | 0.0000e+00 |           0 |    17817600 |            0 |       12800 |        10.9 |reached max iter\nSimulation stopped as no error occurred @ EbNo = 5.5 dB.\n\n```"
"## Training the Neural Receiver\n\nIn the next cell, one forward pass is performed within a *gradient tape*, which enables the computation of gradient and therefore the optimization of the neural network through stochastic gradient descent (SGD).\n\n**Note:** For an introduction to the implementation of differentiable communication systems and their optimization through SGD and backpropagation with Sionna, please refer to [the Part 2 of the Sionna tutorial for Beginners](https://nvlabs.github.io/sionna/examples/Sionna_tutorial_part2.html).\n\n\n```python\n# The end-to-end system equipped with the neural receiver is instantiated for training.\n# When called, it therefore returns the estimated BMD rate\nmodel = E2ESystem('neural-receiver', training=True)\n# Sampling a batch of SNRs\nebno_db = tf.random.uniform(shape=[], minval=ebno_db_min, maxval=ebno_db_max)\n# Forward pass\nwith tf.GradientTape() as tape:\n    rate = model(training_batch_size, ebno_db)\n    # Tensorflow optimizers only know how to minimize loss function.\n    # Therefore, a loss function is defined as the additive inverse of the BMD rate\n    loss = -rate\n```\n\n\nNext, one can perform one step of stochastic gradient descent (SGD). The Adam optimizer is used\n\n\n```python\noptimizer = tf.keras.optimizers.Adam()\n# Computing and applying gradients\nweights = model.trainable_weights\ngrads = tape.gradient(loss, weights)\noptimizer.apply_gradients(zip(grads, weights))\n```\n\n```python\n<tf.Variable 'UnreadVariable' shape=() dtype=int64, numpy=1>\n```\n\n\nTraining consists in looping over SGD steps. The next cell implements a training loop.\n\nAt each iteration: - A batch of SNRs $E_b/N_0$ is sampled - A forward pass through the end-to-end system is performed within a gradient tape - The gradients are computed using the gradient tape, and applied using the Adam optimizer - The achieved BMD rate is periodically shown\n\nAfter training, the weights of the models are saved in a file\n\n**Note:** Training can take a while. Therefore, [we have made pre-trained weights available](https://drive.google.com/file/d/1W9WkWhup6H_vXx0-CojJHJatuPmHJNRF/view?usp=sharing). Do not execute the next cell if you dont want to train the model from scratch."
"```python\n[ ]:\n```\n\n```python\nmodel = E2ESystem('neural-receiver', training=True)\noptimizer = tf.keras.optimizers.Adam()\nfor i in range(num_training_iterations):\n    # Sampling a batch of SNRs\n    ebno_db = tf.random.uniform(shape=[], minval=ebno_db_min, maxval=ebno_db_max)\n    # Forward pass\n    with tf.GradientTape() as tape:\n        rate = model(training_batch_size, ebno_db)\n        # Tensorflow optimizers only know how to minimize loss function.\n        # Therefore, a loss function is defined as the additive inverse of the BMD rate\n        loss = -rate\n    # Computing and applying gradients\n    weights = model.trainable_weights\n    grads = tape.gradient(loss, weights)\n    optimizer.apply_gradients(zip(grads, weights))\n    # Periodically printing the progress\n    if i % 100 == 0:\n        print('Iteration {}/{}  Rate: {:.4f} bit'.format(i, num_training_iterations, rate.numpy()), end='\\r')\n# Save the weights in a file\nweights = model.get_weights()\nwith open(model_weights_path, 'wb') as f:\n    pickle.dump(weights, f)\n```"
"## Evaluation of the Neural Receiver\n\nThe next cell evaluates the neural receiver.\n\n**Note:** Evaluation of the system can take a while and requires having the trained weights of the neural receiver. Therefore, we provide pre-computed results at the end of this notebook.\n\n\n```python\nmodel = E2ESystem('neural-receiver')\n# Run one inference to build the layers and loading the weights\nmodel(1, tf.constant(10.0, tf.float32))\nwith open(model_weights_path, 'rb') as f:\n    weights = pickle.load(f)\nmodel.set_weights(weights)\n# Evaluations\n_,bler = sim_ber(model, ebno_dbs, batch_size=128, num_target_block_errors=100, max_mc_iter=100)\nBLER['neural-receiver'] = bler.numpy()\n\n```\n\n\n```python\nEbNo [dB] |        BER |       BLER |  bit errors |    num bits | block errors |  num blocks | runtime [s] |    status\n---------------------------------------------------------------------------------------------------------------------------------------\n     -5.0 | 2.5993e-01 | 1.0000e+00 |       46314 |      178176 |          128 |         128 |         0.2 |reached target block errors\n     -4.5 | 2.4351e-01 | 1.0000e+00 |       43387 |      178176 |          128 |         128 |         0.1 |reached target block errors\n     -4.0 | 2.2642e-01 | 1.0000e+00 |       40343 |      178176 |          128 |         128 |         0.1 |reached target block errors\n     -3.5 | 2.0519e-01 | 1.0000e+00 |       36560 |      178176 |          128 |         128 |         0.1 |reached target block errors\n     -3.0 | 1.7735e-01 | 1.0000e+00 |       31600 |      178176 |          128 |         128 |         0.1 |reached target block errors\n     -2.5 | 1.2847e-01 | 1.0000e+00 |       22890 |      178176 |          128 |         128 |         0.1 |reached target block errors\n     -2.0 | 4.3592e-02 | 7.9688e-01 |        7767 |      178176 |          102 |         128 |         0.1 |reached target block errors\n     -1.5 | 3.0379e-03 | 1.1830e-01 |        3789 |     1247232 |          106 |         896 |         0.9 |reached target block errors\n     -1.0 | 4.8306e-04 | 7.4219e-03 |        8607 |    17817600 |           95 |       12800 |        13.3 |reached max iter\n     -0.5 | 2.4481e-04 | 2.1875e-03 |        4362 |    17817600 |           28 |       12800 |        13.2 |reached max iter\n      0.0 | 1.9026e-04 | 1.4844e-03 |        3390 |    17817600 |           19 |       12800 |        13.2 |reached max iter\n      0.5 | 7.0436e-05 | 5.4688e-04 |        1255 |    17817600 |            7 |       12800 |        13.3 |reached max iter\n      1.0 | 4.5405e-05 | 3.1250e-04 |         809 |    17817600 |            4 |       12800 |        13.2 |reached max iter\n      1.5 | 3.0083e-05 | 3.1250e-04 |         536 |    17817600 |            4 |       12800 |        13.2 |reached max iter\n      2.0 | 5.8145e-05 | 3.1250e-04 |        1036 |    17817600 |            4 |       12800 |        13.3 |reached max iter\n      2.5 | 1.6276e-05 | 1.5625e-04 |         290 |    17817600 |            2 |       12800 |        13.2 |reached max iter\n      3.0 | 0.0000e+00 | 0.0000e+00 |           0 |    17817600 |            0 |       12800 |        13.2 |reached max iter\nSimulation stopped as no error occurred @ EbNo = 3.0 dB.\n\n```"
"Finally, we plots the BLERs\n\n\n```python\nplt.figure(figsize=(10,6))\n# Baseline - Perfect CSI\nplt.semilogy(ebno_dbs, BLER['baseline-perfect-csi'], 'o-', c=f'C0', label=f'Baseline - Perfect CSI')\n# Baseline - LS Estimation\nplt.semilogy(ebno_dbs, BLER['baseline-ls-estimation'], 'x--', c=f'C1', label=f'Baseline - LS Estimation')\n# Neural receiver\nplt.semilogy(ebno_dbs, BLER['neural-receiver'], 's-.', c=f'C2', label=f'Neural receiver')\n#\nplt.xlabel(r\"$E_b/N_0$ (dB)\")\nplt.ylabel(\"BLER\")\nplt.grid(which=\"both\")\nplt.ylim((1e-4, 1.0))\nplt.legend()\nplt.tight_layout()\n```"
"## Pre-computed Results\n\n```python\n[ ]:\n```\n\n```python\npre_computed_results = \"{'baseline-perfect-csi': [1.0, 1.0, 1.0, 1.0, 1.0, 0.9916930379746836, 0.5367080479452054, 0.0285078125, 0.0017890625, 0.0006171875, 0.0002265625, 9.375e-05, 2.34375e-05, 7.8125e-06, 1.5625e-05, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], 'baseline-ls-estimation': [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 0.9998022151898734, 0.9199448529411764, 0.25374190938511326, 0.0110234375, 0.002078125, 0.0008359375, 0.0004375, 0.000171875, 9.375e-05, 4.6875e-05, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], 'neural-receiver': [1.0, 1.0, 1.0, 1.0, 1.0, 0.9984177215189873, 0.7505952380952381, 0.10016025641025642, 0.00740625, 0.0021640625, 0.000984375, 0.0003671875, 0.000203125, 0.0001484375, 3.125e-05, 2.34375e-05, 7.8125e-06, 7.8125e-06, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]}\"\nBLER = eval(pre_computed_results)\n```"
"## References\n\n[1] M. Honkala, D. Korpi and J. M. J. Huttunen, DeepRx: Fully Convolutional Deep Learning Receiver, in IEEE Transactions on Wireless Communications, vol.20, no. 6, pp.3925-3940, June 2021, doi: 10.1109/TWC.2021.3054520.\n\n[2] F. Ait Aoudia and J. Hoydis, End-to-end Learning for OFDM: From Neural Receivers to Pilotless Communication, in IEEE Transactions on Wireless Communications, doi: 10.1109/TWC.2021.3101364.\n\n[3] Kaiming He, Xiangyu Zhang, Shaoqing Ren, Jian Sun, Deep Residual Learning for Image Recognition, Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition (CVPR), 2016, pp.770-778\n\n[4] G. Bcherer, Achievable Rates for Probabilistic Shaping, arXiv:1707.01134, 2017.\n[4] G. Bcherer, Achievable Rates for Probabilistic Shaping, arXiv:1707.01134, 2017.\n[4] G. Bcherer, Achievable Rates for Probabilistic Shaping, arXiv:1707.01134, 2017."
